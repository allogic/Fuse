#version 460 core

#extension GL_ARB_shading_language_include : require
#extension GL_EXT_nonuniform_qualifier : require

#define VOXEL_EMPTY (0U)

#define VOXEL_IS_SOLID(VOXEL) ((VOXEL & 0x80000000U) == 0x80000000U)

#define VOXEL_SET_SOLID(VOXEL) (VOXEL | 0x80000000U)

struct constant_values_t
{
	ivec3 world_position;
	int lod;
};

layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout (binding = 0) uniform cluster_info_t
{
	ivec3 chunk_count;
	int chunk_size;
	int max_lod_levels;
} cluster_info;

layout (binding = 1, r32ui) uniform uimage3D chunks[];

layout (push_constant) uniform constant_t
{
	constant_values_t values;
} constant;

uint get_voxel(in ivec3 chunk_position, in ivec3 voxel_position, in int lod)
{
	int chunk_index = int(
		(chunk_position.x / cluster_info.chunk_size) +
		(chunk_position.y / cluster_info.chunk_size) * cluster_info.chunk_count.x +
		(chunk_position.z / cluster_info.chunk_size) * cluster_info.chunk_count.x * cluster_info.chunk_count.y
	);

	chunk_index = lod + (chunk_index * cluster_info.max_lod_levels);

	if (chunk_index < (cluster_info.chunk_count.x * cluster_info.chunk_count.y * cluster_info.chunk_count.z * cluster_info.max_lod_levels))
	{
		return uint(imageLoad(chunks[chunk_index], voxel_position).r);
	}

	return VOXEL_EMPTY;
}
void set_voxel(in ivec3 chunk_position, in ivec3 voxel_position, in int lod, in uint voxel)
{
	int chunk_index = int(
		(chunk_position.x / cluster_info.chunk_size) +
		(chunk_position.y / cluster_info.chunk_size) * cluster_info.chunk_count.x +
		(chunk_position.z / cluster_info.chunk_size) * cluster_info.chunk_count.x * cluster_info.chunk_count.y
	);

	chunk_index = lod + (chunk_index * cluster_info.max_lod_levels);

	if (chunk_index < (cluster_info.chunk_count.x * cluster_info.chunk_count.y * cluster_info.chunk_count.z * cluster_info.max_lod_levels))
	{
		imageStore(chunks[chunk_index], voxel_position, uvec4(voxel, 0, 0, 0));
	}
}

void main()
{
	ivec3 chunk_position = constant.values.world_position;

	ivec3 prev_voxel_position = ivec3(gl_GlobalInvocationID.xyz) * 2;
	ivec3 curr_voxel_position = ivec3(gl_GlobalInvocationID.xyz);

	int prev_lod = constant.values.lod - 1;
	int curr_lod = constant.values.lod;

	int prev_chunk_size = cluster_info.chunk_size / (1 << prev_lod);
	int curr_chunk_size = cluster_info.chunk_size / (1 << curr_lod);

	bool prev_is_solid = false;

	for (int z = 0; z < 2; z++)
	{
		for (int y = 0; y < 2; y++)
		{
			for (int x = 0; x < 2; x++)
			{
				uint prev_voxel = get_voxel(chunk_position, prev_voxel_position + ivec3(x, y, z), prev_lod);

				if (VOXEL_IS_SOLID(prev_voxel))
				{
					prev_is_solid = true;
				}
			}
		}
	}

	uint curr_voxel = VOXEL_EMPTY;

	if (prev_is_solid)
	{
		curr_voxel = VOXEL_SET_SOLID(curr_voxel);
	}

	set_voxel(chunk_position, curr_voxel_position, curr_lod, curr_voxel);
}
